#!/usr/bin/env python

from optparse import OptionParser
import boto
import os
import re

def rekelvinate():
    parser = OptionParser()
    parser.add_option("-v", "--verbose", dest="verbose",
                      action="store_true", help="chatty mode")
    parser.add_option("-l", "--list", dest="listonly", 
                      action="store_true",
                      help="only list files needing kelvination, don't actually do")
    parser.add_option("-c", "--class", dest="course_prefix",
                      help="restrict to course prefix, like \"cs144\" or \"nlp\"")
    parser.add_option("-b", "--bucket", dest="bucket", default="stage-c2g",
                      help="S3 bucket to use (default=\"stage-c2g\")")
    global options
    (options, args) = parser.parse_args()

    if ('AWS_ACCESS_KEY_ID' not in os.environ 
            or 'AWS_SECRET_ACCESS_KEY' not in os.environ):
        parser.error("You need to set the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables. " +
                "We use these to access S3.")
        return 1;

    missing = get_missing()

    if options.listonly:
        for v in missing:
            print v
        return

    initiate(missing)


def printv(str):
    if options.verbose:
        print str


def get_missing():
    conn=boto.connect_s3()
    bucket=conn.get_bucket(options.bucket)
    contents_set=bucket.list(options.course_prefix)

    # example: u'nlp/Fall2012/videos/39/jpegs/manifest.txt'
    # video regexp has to handle spaces in video name
    video_re=re.compile(r"(\w*)/(\w*)/videos/(\w*)/[^/]+$")
    manifest_re=re.compile(r"(\w*)/(\w*)/videos/(\w*)/jpegs/manifest.txt$")
    video_id_field=3

    videos={}   # dict of video_id, full S3 path to video
    videos_skip=[]   # ID's of videos with errors, to be skipped

    # first scan for all videos
    for path_result in contents_set:
        path = path_result.name
        video_match = video_re.match(path)
        if video_match:
            video_id = video_match.group(video_id_field)
            if video_id in videos:
                printv("WARNING: duplicate videos found for ID " + video_id + ", skipping")
                printv("    " + videos[video_id])
                printv("    " + path)
                videos_skip.append(video_id)
            else:
                printv("found video " + path)
                videos[video_id] = path

    # now scan for manifests to see which videos to remove.  Doing this
    # in two passes to handle duplicate video_id case
    for path_result in contents_set:
        path = path_result.name
        manifest_match = manifest_re.match(path)
        if manifest_match:
            video_id = video_match.group(video_id_field)
            if any(video_id in v for v in videos_skip):
                printv("found manifest, but skipping because of a dup: " + path)
                next;
            if video_id in videos:
                printv("found manifest, removed: " + deleted)
                deleted = videos.pop(manifest_match.group(video_id_field))
            else:
                printv("found manifest w/out video, ignored: " + path)

    return videos.values()


def initiate(missing):
    pass


if __name__ == "__main__":
    rekelvinate()

